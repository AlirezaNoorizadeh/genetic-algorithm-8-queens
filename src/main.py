# -*- coding: utf-8 -*-
"""8Queens.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WpKLAOjHINWfP3nTZMhhVhwJTQZdTtm6
"""

import numpy as np
import random
from matplotlib import pyplot as plt
import seaborn as sns

POPULATION_SIZE = 100
MUTATION_RATE = 0.1
CROSSOVER_RATE = 0.9
MAX_GENERATIONS = 1000
ELITISM_COUNT = 2

class EightQueensGA:
    def __init__(self):
        self.population = []
        self.best_fitness_history = []
        self.average_fitness_history = []

    def initialize_population(self):

        self.population = []
        for _ in range(POPULATION_SIZE):
            individual = list(np.random.permutation(8))
            self.population.append(individual)

    def calculate_fitness(self, individual):


        clashes = 0
        for i in range(len(individual)):
            for j in range(i+1, len(individual)):

                if abs(i - j) == abs(individual[i] - individual[j]):
                    clashes += 1


        return 28 - clashes

    def evaluate_population(self):


        best_individual = None
        best_fitness = -1
        total_fitness = 0

        for individual in self.population:
            fitness = self.calculate_fitness(individual)
            total_fitness += fitness
            if fitness > best_fitness:
                best_fitness = fitness
                best_individual = individual

        average_fitness = total_fitness / len(self.population)
        self.best_fitness_history.append(best_fitness)
        self.average_fitness_history.append(average_fitness)

        return best_individual, best_fitness

    def selection(self):


        fitness_values = [self.calculate_fitness(ind) for ind in self.population]
        total_fitness = sum(fitness_values)
        probabilities = [f/total_fitness for f in fitness_values]


        parent1, parent2 = random.choices(
            self.population,
            weights=probabilities,
            k=2
        )
        return parent1, parent2

    def crossover(self, parent1, parent2):


        if random.random() > CROSSOVER_RATE:
            return parent1.copy(), parent2.copy()

        size = len(parent1)
        child1, child2 = [-1]*size, [-1]*size

        point1, point2 = sorted(random.sample(range(size), 2))


        child1[point1:point2+1] = parent1[point1:point2+1]
        child2[point1:point2+1] = parent2[point1:point2+1]


        pointer = (point2 + 1) % size
        for gene in parent2[point2+1:] + parent2[:point2+1]:
            if gene not in child1:
                child1[pointer] = gene
                pointer = (pointer + 1) % size


        pointer = (point2 + 1) % size
        for gene in parent1[point2+1:] + parent1[:point2+1]:
            if gene not in child2:
                child2[pointer] = gene
                pointer = (pointer + 1) % size

        return child1, child2

    def mutation(self, individual):

        if random.random() < MUTATION_RATE:
            idx1, idx2 = random.sample(range(len(individual)), 2)
            individual[idx1], individual[idx2] = individual[idx2], individual[idx1]
        return individual

    def create_new_generation(self):

        new_population = []


        sorted_population = sorted(
            self.population,
            key=lambda x: self.calculate_fitness(x),
            reverse=True
        )

        new_population.extend(sorted_population[:ELITISM_COUNT])


        while len(new_population) < POPULATION_SIZE:
            parent1, parent2 = self.selection()
            child1, child2 = self.crossover(parent1, parent2)
            child1 = self.mutation(child1)
            child2 = self.mutation(child2)
            new_population.extend([child1, child2])


        self.population = new_population[:POPULATION_SIZE]

    def run(self):

        self.initialize_population()
        best_individual, best_fitness = self.evaluate_population()

        generation = 0
        while generation < MAX_GENERATIONS and best_fitness < 28:
            self.create_new_generation()
            current_best, current_fitness = self.evaluate_population()

            if current_fitness > best_fitness:
                best_individual = current_best.copy()
                best_fitness = current_fitness

            generation += 1
            if generation % 50 == 0:
                print(f"Generation {generation}: Best Fitness = {best_fitness}")

        return best_individual, best_fitness

    def plot_results(self):

        plt.figure(figsize=(10, 5))
        plt.plot(self.best_fitness_history, label='Best Fitness')
        plt.plot(self.average_fitness_history, label='Average Fitness')
        plt.xlabel('Generation')
        plt.ylabel('Fitness')
        plt.title('Genetic Algorithm Progress')
        plt.legend()
        plt.grid()
        plt.show()

    def visualize_solution(self, solution):

        board = np.zeros((8, 8))
        for col, row in enumerate(solution):
            board[row][col] = 1

        plt.figure(figsize=(6, 6))
        sns.heatmap(board, cmap='binary', linewidths=0.5, linecolor='gray',
                    cbar=False, square=True, xticklabels=False, yticklabels=False)

        plt.title('8 Queens Solution')
        plt.show()


ga = EightQueensGA()
best_solution, best_fitness = ga.run()

print("\nBest Solution Found:")
print(best_solution)
print(f"Fitness: {best_fitness} (Max is 28)")


ga.plot_results()
ga.visualize_solution(best_solution)